<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data import, tidy data, and relational data</title>
    <meta charset="utf-8" />
    <meta name="author" content="Todd Gerarden" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="css/tdg-slides.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">









class: center middle main-title section-title-4

# Data import, tidy data, and relational data

.class-info[

**Week 4**

AEM 2850: R for Business Analytics&lt;br&gt;
Cornell Dyson&lt;br&gt;
Spring 2022

Acknowledgements: 
&lt;!-- [Andrew Heiss](https://datavizm20.classes.andrewheiss.com),  --&gt;
&lt;!-- [Claus Wilke](https://wilkelab.org/SDS375/),  --&gt;
[Grant McDermott](https://github.com/uo-ec607/lectures),
[Jenny Bryan](https://stat545.com/join-cheatsheet.html),
[Allison Horst](https://github.com/allisonhorst/stats-illustrations)

]


---

# Announcements

**Late assignments will get a ✔− going forward**
- If something comes up, email me and Hui in advance

Reminders:
- Submit assignments via canvas
  - Lab 3 was due yesterday (Monday) at 11:59pm
  - Reflection - Week 4 is due Wednesday at 11:59pm
- Bring your laptop to class on Thursday

Questions before we get started?

---

# Plan for today

[Prologue](#prologue)

[Data import](#readr)

[Tidy data](#tidyr)
  &lt;!-- - [pivot_longer](#pivot_longer) / [pivot_wider](#pivot_wider) --&gt;
  &lt;!-- - [separate](#separate) --&gt;
  &lt;!-- - [unite](#unite) --&gt;

[Relational data](#joins)

[Summary](#summary)


---
class: inverse, center, middle
name: prologue

# Prologue


---

# What are our concentrations?

Take a guess: what's the most common concentration among classmates?

--


```
## # A tibble: 39 × 1
##    value                                                 
##    &lt;chr&gt;                                                 
##  1 Business Analytics (AEM) Interactive Technologies (IS)
##  2 Finance                                               
##  3 Business Analytics                                    
##  4 Data Science and Finance                              
##  5 Sustainable Business and Economic Policy              
##  6 Finance                                               
##  7 Finance                                               
##  8 Business Analytics and Strategy                       
##  9 Finance, Business Analytics                           
## 10 Finance                                               
## # … with 29 more rows
```

---

# What are our concentrations?

After some processing to get concentration counts, we get:


```
## # A tibble: 1 × 7
##   accounting    ba  entr enviro finance  food strategy
##        &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;   &lt;int&gt; &lt;int&gt;    &lt;int&gt;
## 1          2    21     2      3      19     2        4
```

What is the "level of observation" in this data frame? (i.e., what are the rows?)

--

Is the best way to organize concentration counts?

--

How would you use counts to compute shares in this data frame?

---

# What are our "tidy" concentrations?

Let's `pivot_longer` and `arrange` to get the top 3:


```
## # A tibble: 3 × 2
##   concentration count
##   &lt;chr&gt;         &lt;int&gt;
## 1 ba               21
## 2 finance          19
## 3 strategy          4
```

--

How would you use counts to compute shares in this data frame?

--


```r
tidy_concentrations %&gt;% mutate(share = count / sum(count)) # easy!
```


```
## # A tibble: 3 × 3
##   concentration count  share
##   &lt;chr&gt;         &lt;int&gt;  &lt;dbl&gt;
## 1 ba               21 0.396 
## 2 finance          19 0.358 
## 3 strategy          4 0.0755
```

---
class: inverse, center, middle
name: readr

# Data import


---

# Data import

Plain-text rectangular files are a common way to store and share data:
- comma delimited files (`readr::read_csv`)
- tab delimited files (`readr::read_tsv`)
- fixed width files (`readr::read_fwf`)

We will just cover csv files since `readr` syntax is transferable

---

# Super bowl ads: a csv example

&lt;img src="img/04/superbowl-ads.png" width="60%" style="display: block; margin: auto;" /&gt;

???
Image source: [FiveThirtyEight](https://github.com/fivethirtyeight/superbowl-ads)

---

# Super bowl ads in csv format

&lt;img src="img/04/superbowl-raw.png" width="100%" style="display: block; margin: auto;" /&gt;

???
Data source: [FiveThirtyEight](https://github.com/fivethirtyeight/superbowl-ads)

---

# Super bowl ads in csv format

&lt;img src="img/04/superbowl-excel.png" width="100%" style="display: block; margin: auto;" /&gt;

---

# Getting from a csv to a data frame

How are data frames and csv files similar?

--
- both are rectangular
- csv lines often correspond to rows
- csv commas delineate columns

--

How are they different?

--
- csv files do not store column types!

---

# 1) readr::read_csv

`read_csv` helps us get from point a to point b:
- you give it the path to your csv file
- it takes the first line of data as column names by default
- it guesses column types and builds up a data frame

Most csv files can be read using the defaults, so we will focus on that

If you run into special cases, consult `?read_csv`

---

# An aside on paths

First we need to figure out what path to give `read_csv`

--

We have several options:
- absolute paths
  - `/Users/todd/aem2850/slides/data/superbowl.csv`
  - `C:\aem2850\slides\data\superbowl.csv`
- relative paths
  - `data/superbowl.csv`
- links
  - [`https://raw.githubusercontent.com/superbowl-ads.csv`](https://raw.githubusercontent.com/fivethirtyeight/superbowl-ads/main/superbowl-ads.csv)
- others
  - see `?read_csv`

---

# An aside on paths

Relative paths are nice: work if you move R code to another directory or device

**But what are they relative to?**

--

The working directory

**But where is the working directory?**

--

**R scripts (.R)** in an R Project: default working directory is the project directory

**R Markdown (.Rmd)**: default working directory is the location of the .Rmd file

--

In our RStudio Cloud projects, these will both be `/cloud/project`, which is the default directory for our projects and where we store our .Rmd templates

---

# An aside on paths

More generally, can check your working directory using `getwd()`

--

For example, here's the working directory the .Rmd source code for these slides:

```r
getwd()
```

```
## [1] "/Users/todd/Documents/GitHub/aem2850/content/slides"
```

`setwd()` will alter the working directory

---

# An aside on paths

Just for context, here is a list of (some) directories below the working directory


```
## .
## ├── css
## ├── data
## ├── img
## └── libs
```

--

Now list (some of) the .csv files in the folder `data`:


```
## data
## └── superbowl.csv
```

`data/superbowl.csv` is the relative path from our working directory to our csv


???

Omitted code that uses `fs::dir_tree` to print pretty directory trees

---

# 1) readr::read_csv

So all we need to do is give that relative path to `read_csv`:


```r
ads &lt;- read_csv("data/superbowl.csv")
```

```
## Rows: 247 Columns: 25
```

```
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: ","
## chr  (10): brand, superbowl_ads_dot_com_url, youtube_url, id, kind, etag, ti...
## dbl   (7): year, view_count, like_count, dislike_count, favorite_count, comm...
## lgl   (7): funny, show_product_quickly, patriotic, celebrity, danger, animal...
## dttm  (1): published_at
```

```
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

--

That was easy!

???
Note: readr intentionally never guesses that columns are integers as a safeguard ([source](https://github.com/tidyverse/readr/issues/1094#issuecomment-628612430))

---

# Now we're back to our old tricks

.pull-left[

```r
ads %&gt;% 
  group_by(funny) %&gt;% 
  count() %&gt;% 
  arrange(desc(n))
```

```
## # A tibble: 2 × 2
## # Groups:   funny [2]
##   funny     n
##   &lt;lgl&gt; &lt;int&gt;
## 1 TRUE    171
## 2 FALSE    76
```
]

.pull-right[

```r
ads %&gt;% 
  group_by(brand) %&gt;% 
  summarize(likes = sum(like_count, na.rm = T)) %&gt;% 
  arrange(desc(likes))
```

```
## # A tibble: 10 × 2
##    brand      likes
##    &lt;chr&gt;      &lt;dbl&gt;
##  1 Doritos   326151
##  2 NFL       224263
##  3 Coca-Cola 160231
##  4 Bud Light 104380
##  5 Budweiser  88765
##  6 Pepsi      14796
##  7 Toyota      5316
##  8 Hynudai     4204
##  9 E-Trade     2624
## 10 Kia         2127
```
]

---

# 2) readr::write_csv

Use `write_csv` to write data to a `.csv`:


```r
write_csv(ads, "data/superbowl.csv") # overwrite the raw data (bad idea!)

ads %&gt;% 
  select(year, brand, youtube_url) %&gt;% 
  write_csv("superbowl-urls.csv") # write modified output to a new file
```

---

# csv is not always the best storage medium

To preserve column specifications and save time when working in R, use `write_rds()` and `read_rds()` to save and open data frames in .RDS format

For multiple objects, `save()` and `load()` are handy functions from base R that work with the .RData format

---

# Importing excel data

Wait, what about getting data from excel spreadsheets?

--

Use `readxl::read_excel()` for data that is stored in `.xls` or `.xlsx` format

`readxl` isn't loaded as part of the core tidyverse, so we need to load it first:


```r
library(readxl)
excel_sheets("data/readxl/datasets.xlsx") # list the sheets in datasets.xlsx
```

```
## [1] "iris"     "mtcars"   "chickwts" "quakes"
```

---

# Importing excel data


```r
read_excel("data/readxl/datasets.xlsx", sheet = "mtcars")
```

```
## # A tibble: 32 × 11
##      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
##  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
##  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
##  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
##  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
##  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
##  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
##  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
##  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
## 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
## # … with 22 more rows
```

---

# Importing excel data

Can also use arguments like `range` to get data using excel lingo


```r
read_excel("data/readxl/datasets.xlsx", 
           range = "mtcars!A1:D6") # note the combination of sheet and cell range
```

```
## # A tibble: 5 × 4
##     mpg   cyl  disp    hp
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  21       6   160   110
## 2  21       6   160   110
## 3  22.8     4   108    93
## 4  21.4     6   258   110
## 5  18.7     8   360   175
```


---
class: inverse, center, middle
name: tidyr

# Tidy data


---

# WHAT is "tidy" data?

---

&lt;img src="img/04/tidydata_1.jpg" width="100%" style="display: block; margin: auto;" /&gt;


---

&lt;img src="img/04/tidydata_2.jpg" width="100%" style="display: block; margin: auto;" /&gt;


---

# WHY "tidy" data?

---

&lt;img src="img/04/tidydata_3.jpg" width="100%" style="display: block; margin: auto;" /&gt;


---

# HOW can we "tidy" data?

**Key tidyr verbs**

1. `pivot_longer`: Pivot wide data into long format (updated version of `gather`) 

2. `pivot_wider`: Pivot long data into wide format (updated version of `spread`) 

3. `separate`: Split one column into multiple columns

4. `unite`: Combine multiple columns into one


---
name: pivot_longer

# Let's start with an untidy dataset


```r
stocks &lt;- data.frame( # could use "tibble" instead of "data.frame" if you prefer
  time = as.Date('2009-01-01') + 0:1,
  X = rnorm(2, 0, 1),
  Y = rnorm(2, 0, 2),
  Z = rnorm(2, 0, 4)
  )
stocks
```

```
##         time          X        Y          Z
## 1 2009-01-01 0.04237688 1.204221  0.6104768
## 2 2009-01-02 0.30644528 2.613880 -4.9524752
```

We have 4 columns, the date and the stocks

How do we get this in tidy form?

---

# 1) tidyr::pivot_longer

We need to pivot the stock name columns `X`, `Y`, `Z` longer

1. Choose columns using `X:Z` or `-time`
2. Decide what variable holds the names: `names_to = "stock"`
3. Decide what variable holds the values: `values_to = "price"`

---

# 1) tidyr::pivot_longer


```r
stocks %&gt;% pivot_longer(X:Z, names_to = "stock", values_to = "price")
```

```
## # A tibble: 6 × 3
##   time       stock   price
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;
## 1 2009-01-01 X      0.0424
## 2 2009-01-01 Y      1.20  
## 3 2009-01-01 Z      0.610 
## 4 2009-01-02 X      0.306 
## 5 2009-01-02 Y      2.61  
## 6 2009-01-02 Z     -4.95
```

--

Let's save the "tidy" (i.e., long) stocks data frame for use on the next slide


```r
tidy_stocks &lt;- stocks %&gt;% 
  pivot_longer(-time, names_to = "stock", values_to = "price")
```

---
name: pivot_wider

# 2) tidyr::pivot_wider


```r
tidy_stocks %&gt;% pivot_wider(names_from = stock, values_from = price)
```

```
## # A tibble: 2 × 4
##   time            X     Y      Z
##   &lt;date&gt;      &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1 2009-01-01 0.0424  1.20  0.610
## 2 2009-01-02 0.306   2.61 -4.95
```

```r
tidy_stocks %&gt;% pivot_wider(names_from = time, values_from = price)
```

```
## # A tibble: 3 × 3
##   stock `2009-01-01` `2009-01-02`
##   &lt;chr&gt;        &lt;dbl&gt;        &lt;dbl&gt;
## 1 X           0.0424        0.306
## 2 Y           1.20          2.61 
## 3 Z           0.610        -4.95
```

--

Note that the second example effectively transposed the original data

---
name: separate

# 3) tidyr::separate




```r
halftime_openers &lt;- data.frame(name = c("Dr.Dre", "Snoop.Dogg"))
halftime_openers
```

```
##         name
## 1     Dr.Dre
## 2 Snoop.Dogg
```

--


```r
halftime_openers %&gt;% separate(name, c("first_name", "last_name")) 
```

```
##   first_name last_name
## 1         Dr       Dre
## 2      Snoop      Dogg
```

--

This command is clever: it splits at non-alphanumeric values. To avoid ambiguity, you can specify the separation character with `separate(..., sep=".")`

---

# 3) tidyr::separate


```r
halftime_performers &lt;- data.frame(name = c("Dr..Dre", "Snoop.Dogg", "Eminem", "Mary.J.Blige",
                                           "Kendrick.Lamar", "50.Cent", "Anderson..Paak"))
```
--

```r
halftime_performers %&gt;% separate(name, c("first_name", "last_name"))
```

```
## Warning: Expected 2 pieces. Additional pieces discarded in 1 rows [4].
```

```
## Warning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].
```

```
##   first_name last_name
## 1         Dr       Dre
## 2      Snoop      Dogg
## 3     Eminem      &lt;NA&gt;
## 4       Mary         J
## 5   Kendrick     Lamar
## 6         50      Cent
## 7   Anderson      Paak
```

What happened? Did we lose any information?

???
No "Blige", no . in "Dr." or ".Paak"

---
name: unite

# 4) tidyr::unite


```r
gdp &lt;- data.frame(
  yr = rep(2016, times = 4),
  mnth = rep(1, times = 4),
  dy = 1:4,
  gdp = rnorm(4, mean = 100, sd = 2)
  )
gdp 
```

```
##     yr mnth dy      gdp
## 1 2016    1  1 101.0797
## 2 2016    1  2 101.3500
## 3 2016    1  3 101.0143
## 4 2016    1  4 102.6158
```

---

# 4) tidyr::unite


```r
# combine "yr", "mnth", and "dy" into one "date" column
gdp %&gt;% unite(date, c("yr", "mnth", "dy"), sep = "-")
```

```
##       date      gdp
## 1 2016-1-1 101.0797
## 2 2016-1-2 101.3500
## 3 2016-1-3 101.0143
## 4 2016-1-4 102.6158
```

---

# 4) tidyr::unite

Note that `unite` will automatically create a character variable:

```r
gdp_u &lt;- gdp %&gt;% unite(date, c("yr", "mnth", "dy"), sep = "-") %&gt;% as_tibble()
gdp_u
```

```
## # A tibble: 4 × 2
##   date       gdp
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 2016-1-1  101.
## 2 2016-1-2  101.
## 3 2016-1-3  101.
## 4 2016-1-4  103.
```

--

To convert it to something else (e.g., date or numeric), modify it using `mutate`

---

# 4) tidyr::unite


```r
library(lubridate) # the lubridate package has helpful date conversion functions
gdp_u %&gt;% mutate(date = ymd(date))
```

```
## # A tibble: 4 × 2
##   date         gdp
##   &lt;date&gt;     &lt;dbl&gt;
## 1 2016-01-01  101.
## 2 2016-01-02  101.
## 3 2016-01-03  101.
## 4 2016-01-04  103.
```

???
https://lubridate.tidyverse.org/

---

# tidyr resources

[Data tidying with tidyr : : CHEAT SHEET](https://raw.githubusercontent.com/rstudio/cheatsheets/main/tidyr.pdf) (link downloads a pdf)

[Vignette](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) (from the **tidyr** package)

```r
vignette("tidy-data")
```

[Original paper](https://vita.had.co.nz/papers/tidy-data.pdf) (Hadley Wickham, 2014 JSS)


---
class: inverse, center, middle
name: joins

# Relational data


---

# What are relational data?

--

Multiple tables of data with pairwise relations

Relations across &gt;2 data tables are determined by the relations between each pair

---

# Relational data verbs from dplyr

1. **Mutating joins**: add new variables
  - `left_join()`
  - `right_join()`
  - `inner_join()`
  - `full_join()`

2. **Filtering joins**: filter observations
  - `semi_join()`
  - `anti_join()`


&lt;!-- --- --&gt;

&lt;!-- # How do join verbs work? --&gt;


&lt;!-- From Ivan Rudik's slides: --&gt;

&lt;!-- We need two datasets (e.g., housing prices and pollution) --&gt;

&lt;!-- Each dataset has the same set of **key** variables (e.g. county) --&gt;

&lt;!-- When we join, we match up the two datasets on the key, and combine them into one --&gt;

&lt;!-- In our housing example, each row of the joined dataset would now tell us the house price, the county it's in, and the county's pollution --&gt;

???

You can visualize the operations [here](https://r4ds.had.co.nz/relational-data.html)

---

# Joins

Let's learn these join commands using two small data frames



.pull-left[

```r
superheroes
```

```
## # A tibble: 7 × 4
##   name     alignment gender publisher        
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;            
## 1 Magneto  bad       male   Marvel           
## 2 Storm    good      female Marvel           
## 3 Mystique bad       female Marvel           
## 4 Batman   good      male   DC               
## 5 Joker    bad       male   DC               
## 6 Catwoman bad       female DC               
## 7 Hellboy  good      male   Dark Horse Comics
```
]

.pull-right[

```r
publishers
```

```
## # A tibble: 3 × 2
##   publisher yr_founded
##   &lt;chr&gt;          &lt;int&gt;
## 1 DC              1934
## 2 Marvel          1939
## 3 Image           1992
```
]

???
Source: https://stat545.com/join-cheatsheet.html


---

# 1) dplyr::left_join(x, y)


```r
left_join(superheroes, publishers)
```

```
## Joining, by = "publisher"
```

```
## # A tibble: 7 × 5
##   name     alignment gender publisher         yr_founded
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;                  &lt;int&gt;
## 1 Magneto  bad       male   Marvel                  1939
## 2 Storm    good      female Marvel                  1939
## 3 Mystique bad       female Marvel                  1939
## 4 Batman   good      male   DC                      1934
## 5 Joker    bad       male   DC                      1934
## 6 Catwoman bad       female DC                      1934
## 7 Hellboy  good      male   Dark Horse Comics         NA
```

`left_join` is a **mutating join**: it adds variables to `x`

`left_join` returns all rows from `x`

---

# 2) dplyr::right_join(x, y)


```r
right_join(superheroes, publishers)
```

```
## Joining, by = "publisher"
```

```
## # A tibble: 7 × 5
##   name     alignment gender publisher yr_founded
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;          &lt;int&gt;
## 1 Magneto  bad       male   Marvel          1939
## 2 Storm    good      female Marvel          1939
## 3 Mystique bad       female Marvel          1939
## 4 Batman   good      male   DC              1934
## 5 Joker    bad       male   DC              1934
## 6 Catwoman bad       female DC              1934
## 7 &lt;NA&gt;     &lt;NA&gt;      &lt;NA&gt;   Image           1992
```

`right_join` is a **mutating join**: it adds variables to `y`

`right_join` returns all rows from `y`

---

# 3) dplyr::inner_join(x, y)


```r
inner_join(superheroes, publishers)
```

```
## Joining, by = "publisher"
```

```
## # A tibble: 6 × 5
##   name     alignment gender publisher yr_founded
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;          &lt;int&gt;
## 1 Magneto  bad       male   Marvel          1939
## 2 Storm    good      female Marvel          1939
## 3 Mystique bad       female Marvel          1939
## 4 Batman   good      male   DC              1934
## 5 Joker    bad       male   DC              1934
## 6 Catwoman bad       female DC              1934
```

How is `inner_join` different from `left_join` and `right_join`?

--

`inner_join` returns all rows in `x` **AND** `y`

---

# 4) dplyr::full_join(x, y)


```r
full_join(superheroes, publishers) # how many rows will this produce?
```

--


```
## Joining, by = "publisher"
```

```
## # A tibble: 8 × 5
##   name     alignment gender publisher         yr_founded
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;                  &lt;int&gt;
## 1 Magneto  bad       male   Marvel                  1939
## 2 Storm    good      female Marvel                  1939
## 3 Mystique bad       female Marvel                  1939
## 4 Batman   good      male   DC                      1934
## 5 Joker    bad       male   DC                      1934
## 6 Catwoman bad       female DC                      1934
## 7 Hellboy  good      male   Dark Horse Comics         NA
## 8 &lt;NA&gt;     &lt;NA&gt;      &lt;NA&gt;   Image                   1992
```

`full_join` returns all rows in `x` **OR** `y`

---

# 5) dplyr::semi_join(x, y)

.pull-left[

```r
superheroes
```

```
## # A tibble: 7 × 4
##   name     alignment gender publisher        
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;            
## 1 Magneto  bad       male   Marvel           
## 2 Storm    good      female Marvel           
## 3 Mystique bad       female Marvel           
## 4 Batman   good      male   DC               
## 5 Joker    bad       male   DC               
## 6 Catwoman bad       female DC               
## 7 Hellboy  good      male   Dark Horse Comics
```
]

.pull-right[

```r
semi_join(superheroes, publishers)
```

```
## Joining, by = "publisher"
```

```
## # A tibble: 6 × 4
##   name     alignment gender publisher
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;    
## 1 Magneto  bad       male   Marvel   
## 2 Storm    good      female Marvel   
## 3 Mystique bad       female Marvel   
## 4 Batman   good      male   DC       
## 5 Joker    bad       male   DC       
## 6 Catwoman bad       female DC
```
]

`semi_join` is a **filtering join**: it keeps observations in `x` that have a match in `y`

Note that the variables do not change

---

# 6) dplyr::anti_join(x, y)

.pull-left[

```r
superheroes
```

```
## # A tibble: 7 × 4
##   name     alignment gender publisher        
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;            
## 1 Magneto  bad       male   Marvel           
## 2 Storm    good      female Marvel           
## 3 Mystique bad       female Marvel           
## 4 Batman   good      male   DC               
## 5 Joker    bad       male   DC               
## 6 Catwoman bad       female DC               
## 7 Hellboy  good      male   Dark Horse Comics
```
]

.pull-right[

```r
anti_join(superheroes, publishers)
```

```
## Joining, by = "publisher"
```

```
## # A tibble: 1 × 4
##   name    alignment gender publisher        
##   &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;            
## 1 Hellboy good      male   Dark Horse Comics
```
]

`anti_join` is a **filtering join**: it keeps obs. in `x` that **DO NOT** have a match in `y`

Note that the variables do not change


---
class: inverse, center, middle
name: summary

# Summary

---

# Key verbs

.pull-left-4[
### Import
#### readr
1. `read_csv`
2. `write_csv`

#### readxl
1. `read_excel`
]

.pull-midleft-4[
### Tidy
#### tidyr
1. `pivot_longer`
2. `pivot_wider`
3. `separate`
4. `unite`
]

.pull-midright-4[
### Join
#### dplyr
1. `left_join`
2. `right_join`
3. `inner_join`
4. `full_join`
5. `semi_join`
6. `anti_join`
]

.pull-right-4[
### Transform
#### dplyr
1. `filter`
2. `arrange`
3. `select`
4. `mutate`
5. `summarize`
]


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"slideNumberFormat": "%current%",
"ratio": "16:9",
"navigation": {
"scroll": false
}
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
