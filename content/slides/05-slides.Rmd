---
title: "Strings and regular expressions"
author: "Todd Gerarden"
output:
  xaringan::moon_reader:
    lib_dir: "libs"
    css: ["xaringan-themer.css", "css/tdg-slides.css"]
#    css: ['default', 'metropolis', 'metropolis-fonts']
    seal: false
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%"
      ratio: "16:9"
      navigation:
        scroll: false
      # beforeInit: "libs/offline-mathjax.js"
editor_options: 
  chunk_output_type: console
---

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_mono_accent(base_color = "#B31B1B",
                  text_font_size = "1.4rem")
xaringanExtra::use_xaringan_extra(c("tile_view"))
```

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(warning = FALSE, message = FALSE, 
                      #cache = TRUE,
                      fig.retina = 3, fig.align = "center",
                      fig.width=14, fig.height=7)
```

```{r packages-data, include=FALSE}
library(tidyverse)

# options("digits" = 2, "width" = 90)
```


class: center, middle

# Strings and regular expressions

.class-info[

**Week 5**

AEM 2850 / 5850 : R for Business Analytics<br>
Cornell Dyson<br>
Spring 2023

Acknowledgements: 
<!-- [Andrew Heiss](https://datavizm20.classes.andrewheiss.com), -->
<!-- [Claus Wilke](https://wilkelab.org/SDS375/),  -->
<!-- [Grant McDermott](https://github.com/uo-ec607/lectures), -->
<!-- [Jenny Bryan](https://stat545.com/join-cheatsheet.html), -->
<!-- [Allison Horst](https://github.com/allisonhorst/stats-illustrations) -->
[R4DS (2e)](https://r4ds.hadley.nz)

]

---

# Announcements

No lab due next Monday (February break)

Prelim 1 will be next Thursday, March 2 at 9:40am in class
  - Will cover everything including this week's material
  - We are still writing the prelim, will provide more guidance Thursday and via canvas

Questions before we get started?


---

# Plan for today

[Prologue: clarifying group operations](#prologue)

[Working with strings in R](#working-with-strings)

[Regular expressions](#regex)


---
class: inverse, center, middle
name: prologue

# Prologue

---

# Group operations

Lab-04 included the following question:

> **3. Calculate the average housing price for each of the cities that are in `tidy_txhouse` and in `tidy_txpop` over the period 2010 through 2012. Which city has the highest average housing price? Which city has the lowest average housing price?**

--

This is a good example question to provide more detail on `group_by()` and `ungroup()`, which I mentioned in passing during week 2

*Aside: if we penalize you on this question due to confusion about the "and in" vs "but not in" verbiage in the question, reach out via email and we will regrade them.*

```{r, echo=FALSE}
tidy_txhouse <- read_csv("data/05-slides/tidy_txhouse.csv", show_col_types = FALSE)
tx_pop_city <- read_csv("data/05-slides/tidy_txpop.csv", show_col_types = FALSE) |> 
  distinct(city)
```

---

# Reminder: dplyr::group_by

`summarize` is particularly useful in combination with `group_by`:

```{r}
semi_join(tidy_txhouse, tx_pop_city) |>   # for cities in tidy_txhouse and tx_pop_city
  filter(2010 <= year & year <= 2012) |>  # for years 2010-2012
  group_by(city) |>                       # for each city #<< 
  summarize(mean_price = mean(price))     # compute the mean price #<<
```

---

# Groups are persistent (sort of)

.pull-left[
```{r, highlight.output = c(2, 5, 6, 7)}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  print(n = 5)
```
]

--

.pull-right[
```{r, highlight.output = 4}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  summarize(mean_price = mean(price)) |> 
  print(n = 5)
```
No groups?!
]

---

# Groups are persistent (sort of)

.pull-left[
`summarize()` drops the last group variable, so the output is not grouped by `city`

By contrast `mutate()` does not unroll group variables unless you explicitly ask it to
]

.pull-right[
```{r, highlight.output = c(2, 5, 6, 7)}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  mutate(mean_price = mean(price))
```
]

---

# Groups affect filter operations!

.pull-left[
```{r}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  summarize(mean_price = mean(price)) |> #<<
  filter(mean_price == max(mean_price)) #<<
```

Looks good!
]

--

.pull-right[
```{r, highlight.output = 2}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  mutate(mean_price = mean(price)) |> #<<
  filter(mean_price == max(mean_price)) |>  #<<
  head(5)
```

What went wrong?
]

---

# Reminder: dplyr::ungroup

```{r echo=FALSE, out.width='65%'}
knitr::include_graphics("img/02/group_by_ungroup.png")
```

Groups are persistent (sort of), `ungroup` removes them

---

# Groups affect filter operations!

.pull-left[
One way to get around this is to use `ungroup()` or `group_by()` with no arguments

Now we get Austin and only Austin

But we still get multiple rows, when we only need/want one
]

.pull-left[
```{r, highlight.output = 2}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  mutate(mean_price = mean(price)) |> 
  ungroup() |> #<<
  filter(mean_price == max(mean_price)) |> 
  head(5)
```
]


---
class: inverse, center, middle
name: working-with-strings

# Working with strings in R

---

# Strings are nothing new

.pull-left[
```{r highlight.output = 3}
nycflights13::flights |> 
  select(carrier, tailnum, origin, dest)
```
]

.pull-right[
```{r highlight.output = 3, include=FALSE}
read_csv("data/our-companies.csv") |> 
  select(name)
```

```{r highlight.output = 3}
tx_pop_city |> 
  select(city)
```

]

---

# Strings in R

Strings are also referred to as "characters" (abbreviated `chr`)

Strings can be stored in many ways:
- Vectors
- **Data frame columns**
- Elements in a list

So far we have used them as we would any other data

--

**But sometimes we'll want to filter on, modify, or analyze strings**

---

# The stringr package

`stringr` is loaded as part of the core tidyverse

All `stringr` functions have intuitive names that start with `str_`

We will cover a bunch of handy functions today:
1. `str_length`
2. `str_trim`
3. `str_c` and `str_glue`
4. `str_detect`
5. `str_count`
6. `str_replace`

See `vignette("stringr")` for more

---

# We'll use data from The Office

The `schrute` package contains transcripts of all episodes of [The Office](https://www.imdb.com/title/tt0386676/) (US)

```{r}
library(schrute)
theoffice # this is an object from the schrute package
```


---

# 1) stringr::str_length

--

`str_length` tells you the number of characters in a string

--

```{r}
str_length("supercalifragilisticexpialidocious")
```

--
```{r}
theoffice |> 
  distinct(character) |> 
  slice_head(n = 5) |> 
  mutate(name_length = str_length(character)) #<<
```

---

# 2) stringr::str_trim

--

`str_trim` removes leading/trailing whitespace

--

```{r}
str_trim("I went to Cornell, you ever heard of it?            ")
```

--

```{r}
str_trim("            I went to Cornell, you ever heard of it?  ")
```


---

# 3) stringr::str_c

--

We have seen `c()` combine arguments into a vector or list

Similarly, `str_c()` combines arguments into a character vector:
```{r}
str_c("a", "b", "c", "1", "2", "3")
```

Here, it combined three numbers into a single number

But we can also use it within data frames to combine strings at scale

---

# 3) stringr::str_c

Here's an example of multiple columns in a data frame being combined into one:

```{r}
theoffice |> slice_head(n = 1) |> 
  select(character, text)
```

```{r, eval=FALSE}
theoffice |> slice_head(n = 1) |> 
    transmute(line = str_c(character, " said: ", text)) # mutate and keep only line #<<
```

--

```{r, echo=FALSE}
theoffice |> slice_head(n = 1) |> 
    transmute(line = str_c(character, " said: ", text)) # mutate and keep only line #<<
```

---

# 3) stringr::str_c

`str_c()` will automatically recycle fixed arguments like **" said: "** that are shorter than `character` and `text`:

```{r}
theoffice |> slice_head(n = 3) |> 
    transmute(line = str_c(character, " said: ", text))
```

--

`str_c()` and `str_glue()` work well with `mutate()` and `transmute()` because their output is the same length as their inputs

---

# 3) stringr::str_glue

`str_glue()` provides similar functionality, but different syntax:

```{r}
theoffice |> slice_head(n = 3) |> 
    transmute(line = str_glue("{character} said: {text}")) # note the different syntax #<<
```

Items inside `{}` are evaluated as if they are outside the quotes

This can be handy when combining many fixed and variable strings

---
class: inverse, center, middle
name: regex

# Regular expressions

---

# Regular expressions

...

<!-- https://r4ds.hadley.nz/regexps.html#sec-reg-basics -->

---

# 4) stringr::str_detect

--

`str_detect` can be used to match patterns

--

.pull-left[
```{r}
first_4_characters <- theoffice |> 
  distinct(character) |> 
  slice_head(n = 4) |> 
  pull(character)
first_4_characters
```
]

--

.pull-right[
```{r}
str_detect(first_4_characters, "Dwight")

str_detect(first_4_characters, "a")
```
]

---

# 4) stringr::str_detect

`str_detect` is a powerful way to `filter` a data frame

--

```{r}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text,    # where to match a pattern #<<
                    "sale")) # what pattern to match #<<
```

---

# 4) stringr::str_detect

`str_detect` is case-sensitive by default

```{r}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text, 
                    "Sale")) # sale and Sale produce different output #<<
```

---

# 4) stringr::str_detect

You could use multiple calls to `str_detect`, or pass multiple arguments:

```{r highlight.output = c(6, 10)}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text, 
                    "sale|Sale")) # look for sale OR Sale #<<
```

---

# 4) stringr::str_detect

You could consolidate this -- regex parentheses are like in math

```{r}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text, 
                    "(s|S)ale")) # look for sale OR Sale #<<
```

---

# 4) stringr::str_detect

You could `regex` to ignore all cases and control other pattern matching details

```{r}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text, 
                    regex("Sale", ignore_case = TRUE))) # ignore case #<<
```


---

# 4) stringr::str_detect

When I say ignore all cases, I mean IGNORE ALL CASES!

```{r}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text, 
                    regex("sale", ignore_case = TRUE))) |>
  filter(!str_detect(text, "(s|S)ale")) # find non-standard form(s) #<<
```

---

# 4) stringr::str_detect

`str_detect` can be combined with familiar functions to summarize data

--

```{r}
theoffice |> 
  filter(str_detect(text, regex("Sale", ignore_case = TRUE))) |> 
  count(character, sort = TRUE) #<<
```

---

# 4) stringr::str_detect

`str_detect` can be combined with familiar functions to summarize data

```{r}
theoffice |> 
  filter(str_detect(text, 
                    regex("that's what she said", ignore_case = TRUE))) |> #<<
  count(character, sort = TRUE)
```

---

# 4) stringr::str_detect

`str_detect` with regular expressions can be very powerful

```{r highlight.output = c(5,6)}
theoffice |> select(character, text) |> 
  filter(str_detect(text, "assistant.*manager")) |> #<<
  slice_head(n = 10)
```

---

# 5) stringr::str_count

`str_count()` can be used to count the number of matches in a string

```{r}
theoffice |> 
  distinct(character) |> 
  slice_head(n = 5) |> 
  mutate(
    name = str_to_lower(character), # one way to avoid case sensitivity
    m_s = str_count(name, "m"), #<<
    i_s = str_count(name, "i") #<<
  )
```

---

# 5) stringr::str_count with regex

Character classes, defined by `[]`, let you match a set of characters; `^` can be used to invert character class matches

```{r}
theoffice |> 
  distinct(character) |> 
  slice_head(n = 5) |> 
  mutate(
    name = str_to_lower(character),
    vowels = str_count(name, "[aeiou]"), # count matches of ANY of these characters #<<
    consonants = str_count(name, "[^aeiou]") # count matches of everything EXCEPT these characters #<<
  )
```

---

# 6) stringr::str_replace

<!-- https://r4ds.hadley.nz/regexps.html#replace-values -->

