---
title: "Welcome to the tidyverse"
author: "Todd Gerarden"
output:
  xaringan::moon_reader:
    lib_dir: "libs"
    css: ["xaringan-themer.css", "css/tdg-slides.css"]
#    css: ['default', 'metropolis', 'metropolis-fonts']
    seal: false
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%"
      ratio: "16:9"
      navigation:
        scroll: false
      # beforeInit: "libs/offline-mathjax.js"
editor_options: 
  chunk_output_type: console
---

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_mono_accent(base_color = "#B31B1B",
                  text_font_size = "1.4rem")
```

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(#warning = FALSE, message = FALSE, 
                      #cache = TRUE,
                      fig.retina = 3, fig.align = "center",
                      fig.width=14, fig.height=7)
```

```{r packages, include=FALSE}
# do not load tidyverse here in order to show output below # library(tidyverse)
```

```{r xaringanExtra, echo=FALSE}
xaringanExtra::use_xaringan_extra(c("tile_view"))
```


class: center middle main-title section-title-4

# Welcome to the tidyverse

.class-info[

**Week 3**

AEM 2850: R for Business Analytics<br>
Cornell Dyson<br>
Spring 2022

Acknowledgements: 
<!-- [Andrew Heiss](https://datavizm20.classes.andrewheiss.com),  -->
<!-- [Claus Wilke](https://wilkelab.org/SDS375/),  -->
[Grant McDermott](https://github.com/uo-ec607/lectures),
[Allison Horst](https://github.com/allisonhorst/stats-illustrations)

]


---

# Announcements

If you are new to the class, please review canvas announcements

Reminders:
- Bookmark [aem2850.toddgerarden.com/schedule](https://aem2850.toddgerarden.com/schedule) and visit often
- Submit assignments via canvas
  - Lab 2 was due yesterday (Monday) at 11:59pm
  - Reflection - Week 3 is due Wednesday at 11:59pm

**Bring your laptop to class on Thursday!**

Questions before we get started?

---

# Plan for today

[Prologue](#prologue)

[Tidyverse basics](#basics)

[Data transformation with dplyr](#dplyr)
  - [filter](#filter)
  - [arrange](#arrange)
  - [select](#select)
  - [mutate](#mutate)
  - [summarize](#summarize)
  - [other goodies](#goodies)


---
class: inverse, center, middle
name: prologue

# Prologue

---

# What sports do we watch?

Take a guess: what's the most popular spectator sport among classmates?

```{r, echo = FALSE}
library(magrittr)
load("data/survey-responses/sports.RData")
```

--

```{r, echo = FALSE}
sports
```

--

Let's `count` and `arrange` to get the top 3:

```{r, echo = FALSE}
# now show off what we can do with summarize()
tibble::tibble(sport = sports) %>% 
  dplyr::count(sport) %>% 
  dplyr::arrange(desc(n)) %>% 
  head(3)
```

---

# R can be used for sports analytics, too!

.pull-left[
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics("img/03/stephen-curry.png")
```
]

.pull-right[
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics("img/03/kobe-bryant.png")
```
]

???
Source: https://github.com/toddwschneider/ballr


---

# R "dialects"

Last week we introduced several R programming concepts:
  - logical expressions
  - assignment
  - object types
  - object names, namespace conflicts
  - indexing

We did this using base R
  - **pro:** comes in the box, close parallels to other programming languages
  - **con:** can be confusing for new programmers (esp. indexing operations)

---

# R "dialects"

.more-left[
This week we will start using the tidyverse

You can think of it as a different "dialect" of R

This dialect is more like human language

More intuitive if you're new to programming

So if Lab 2 was confusing, don't get discouraged!
]

--

.less-right[
```{r echo=FALSE, out.width='100%'}
knitr::include_graphics("img/03/r_first_then.png")
```
]

---
class: inverse, center, middle
name: basics

# Tidyverse basics


---

# Tidyverse vs. base R

Lots of debate over tidyverse vs. base R

--

Why we're using the tidyverse:
- Consistent philosophy and syntax
- Great documentation and community support
- For data wrangling and plotting, tidyverse is ðŸ”¥

--

<br>

Base R is still great, can do some things tidyverse can't

**data.table** is another great alternative for data wrangling


---

# Tidyverse vs. base R

Often a correspondence between tidyverse and base R commands:

| tidyverse  |  base |
|---|---|
| `?readr::read_csv`  | `?utils::read.csv` |
|  `?dplyr::if_else` |  `?base::ifelse` |
|  `?tibble::tibble` |  `?base::data.frame` |

Tidyverse alternatives typically offer extra features

--

**Remember:** There are always multiple ways to do something in R

---

# Let's load the tidyverse meta-package

```{r tverse, cache = FALSE, eval = FALSE}
library(tidyverse)
```

--

```{r tverse-output, cache = FALSE, echo = FALSE}
library(tidyverse)
```

--

We just loaded a bunch of packages: **ggplot2**, **tibble**, **dplyr**, etc.

We also see some **namespace conflicts**

---

# Tidyverse packages

When you install the tidyverse, you actually get a lot more packages:
```{r tverse_pkgs}
tidyverse_packages()
```

--

These other packages have to be loaded separately

---

# Tidyverse packages

Today we'll focus on [**dplyr**](https://dplyr.tidyverse.org/)

But first let's talk about tibbles and pipes


---
name: tibbles

# Review: What are objects? 

There are many different *types* (or *classes*) of objects

Here are some objects that we'll be working with regularly:
- vectors
- matrices
- data frames
- lists
- functions


---

# Review: Data frames

The most important object we'll work with is the **data frame**

You can think of it as an Excel spreadsheet

```{r d}
# Create a small data frame called "d"
d <- data.frame(x = 1:2, y = 3:4) 
d
```

This is essentially just a table with columns named `x` and `y`

Each row is an observation telling us the values of both `x` and `y`

---

# Tibbles are data frames with opinions

For this class you can think of tibbles and data frames as synonymous

Tibbles have some advantages, such as pretty printing

--

We will primarily use tibbles in this course

Two functions may come in handy:
- `as_tibble()` converts data frames to tibbles
- `tibble()` creates new tibbles from scratch

See `vignette("tibble")` for more

---

# Printing a data.frame

```{r data.frame}
as.data.frame(starwars)
```

---

# How could we make this look nicer?

```{r data.frame.nicer}
as.data.frame(starwars)
```

---

# Printing a data.frame with head()

```{r data.frame.head}
head(as.data.frame(starwars))
```

---

# Printing a tibble

```{r tibble, highlight.output = c(1, 3, 14, 15)}
starwars
```

---
name: pipes

# Pipes

**Generic programming question:** Does anyone know what pipes do?

--

Pipes allow us to pass information through a sequence of operations

--

The tidyverse loads its own pipe operator, denoted `%>%`

**Keyboard shortcut:** use `Ctrl/Cmd+Shift+m` to insert `%>%` (with spaces)

---

# Pipe usage

To see why using pipes is so powerful, consider this contrived example based on what we did this morning:

1. Wake up
2. Get out of bed
4. Get dressed
5. Drink coffee
6. Go to class


---

# A day without pipes

You could code this through a series of assignment operations:

```{r, eval = FALSE}
me <- wake_up(me)
me <- get_out_of_bed(me)
me <- get_dressed(me)
me <- drink(me, "coffee")
me <- go(me, "class")
```

Or by putting all these operations in a single line of code:

```{r, eval = FALSE}
me <- go(drink(get_dressed(get_out_of_bed(wake_up(me))), "coffee"), "class")
```

Neither is ideal

---

# Pipes are the best of both worlds

We can do everything at once, in order:

```{r, eval = FALSE}
me %>% 
  wake_up() %>% 
  get_out_of_bed() %>% 
  get_dressed() %>% 
  drink("coffee") %>% 
  go("class")
```

Emphasis is on verbs (e.g., `wake_up`, `get_out_of_bed`, etc.), not nouns (i.e., `me`)

---

# Pipes: Best practices

Write linear code

Spread code out for readability: use one line per verb

Don't use pipes...
- when you need more than 10 (use intermediate objects instead)
- for multiple inputs or outputs
- for non-linear relationships

--

**Aside:** due to the popularity of `%>%`, base R now includes a native pipe `|>` with slightly different properties. We will use `%>%` in this class.

---
class: inverse, center, middle
name: dplyr

# dplyr

---

# What is dplyr?

```{r echo=FALSE, out.width='60%'}
knitr::include_graphics("img/03/dplyr_wrangling.png")
```

---

# What is dplyr?

The dplyr package provides a **grammar of data manipulation**

--

dplyr's functions are **verbs** that correspond to things we want to **do**

--

dplyr functions all have these things in common:
1. their first argument is a data frame
2. their other arguments describe what you want to do
3. their output is a new data frame

--

1 + 3 + `%>%` allow us to combine simple steps to achieve complex results

---

# dplyr has five key verbs we will use

1. `filter`: subset rows based on their values

2. `arrange`: reorder rows based on their values

3. `select`: select columns (i.e., variables)

4. `mutate`: create new columns

5. `summarize`: collapse multiple rows into a single summary value


---

# dplyr verbs operate on different things

- Rows:
  - `filter`: subset rows based on their values
  - `arrange`: reorder rows based on their values
- Columns:
  - `select`: select columns (i.e., variables)
  - `mutate`: create new columns
- Groups of rows:
  - `summarize`: collapse multiple rows into a single summary value

--

Let's study these commands together using the `starwars` data frame that comes pre-packaged with dplyr

---

# Starwars

As a reminder, this is what the `starwars` dataset looks like:

```{r}
starwars
```


---
name: filter

# 1) dplyr::filter

```{r echo=FALSE, out.width='85%'}
knitr::include_graphics("img/03/dplyr_filter.jpg")
```

---

# 1) dplyr::filter

`filter` allows us to focus on certain rows / observations

--

For example, you may only be interested in droids:

```{r filter0}
starwars %>% 
  filter(species == "Droid") 
```

---

# 1) dplyr::filter

Or perhaps you want to subset the humans that are taller than I am:

```{r filter1, eval = FALSE}
starwars %>% 
  filter( 
    species == "Human", 
    height >= 194
    ) 
```

Can you name one? *Hint: there's only one*

--

```{r filter1b, echo = FALSE, highlight.output = c(4)}
starwars %>% 
  filter( 
    species == "Human", 
    height >= 194
    ) 
```


---

# 1) dplyr::filter

Regular expressions work here too, with the help of the `stringr` package:
```{r filter2}
starwars %>% 
  filter(stringr::str_detect(name, "Skywalker"))
```

--

Or you can use `grepl` to achieve the same goal:
```{r filter2b, eval = FALSE}
starwars %>% 
  filter(grepl("Skywalker", name))
```

---

# 1) dplyr::filter

A very common `filter` use case is identifying/removing missing data:
```{r filter3}
starwars %>% 
  filter(is.na(height))
```

---

# 1) dplyr::filter

How could you build on this to remove missing observations?

--

```{r filter4}
starwars %>% 
  filter(!is.na(height)) # use ! for negation
```

---
name: arrange

# 2) dplyr::arrange

`arrange` sorts the data frame based on the variable(s) you supply:

```{r arrange1}
starwars %>% 
  arrange(birth_year)
```

---

# 2) dplyr::arrange

We can also arrange items in descending order using `arrange(desc())`:
```{r arrange2}
starwars %>% 
  arrange(desc(birth_year))
```

---
name: select

# 3) dplyr::select

`select` allows us to select columns / variables:

.pull-left[
```{r select0, highlight.output = 1}
starwars %>% select(name)
```
]

--

.pull-right[
`select` returns a tibble even though you only asked for one variable

To get a vector, you can use:
- `starwars %>% pull(name)`

Or, from base R:
- `starwars %>% .$name`
- `starwars %>% .[["name"]]`
]

---

# 3) dplyr::select

You can get fancy: use commas to select multiple columns, deselect a column using "-", and select consecutive columns using "first:last"
```{r select1}
starwars %>% 
  select(name:skin_color, species, -height)
```

---

# 3) dplyr::select

You can also rename your selected variables at the same time:
```{r select2}
starwars %>%
  select(alias = name, crib = homeworld)
```

---

# 3) dplyr::select

If you just want to rename columns without subsetting them, use `rename`:
```{r rename2}
starwars %>%
  rename(alias = name, crib = homeworld)
```

---

# 3) dplyr::select

`select(contains(PATTERN))` provides a handy shortcut:
```{r select3}
starwars %>% 
  select(name, contains("color"))
```

---

# 3) dplyr::select

`select(..., everything())` is another useful shortcut to move important variables to the "front" of a data frame

```{r select4}
starwars %>% 
  select(species, homeworld, everything()) %>%
  head(5)
```

---

# 3) dplyr::~~select~~ relocate

You can also use `relocate` to reorder columns without subsetting:
```{r relocate4}
starwars %>% 
  relocate(species, homeworld) %>%
  head(5)
```

---
# 3) dplyr::~~select~~ relocate

```{r echo=FALSE, out.width='65%'}
knitr::include_graphics("img/03/dplyr_relocate.png")
```

---
name: mutate

# 4) dplyr::mutate

```{r echo=FALSE, out.width='55%'}
knitr::include_graphics("img/03/dplyr_mutate.png")
```

---

# 4) dplyr::mutate

You can create new columns from scratch or by transforming existing columns:
```{r mutate1}
starwars %>% 
  select(name, birth_year) %>%
  mutate(dog_years = birth_year * 7) %>%
  mutate(comment = paste0(name, " is ", dog_years, " in dog years."))
```

---


# 4) dplyr::mutate

`mutate` creates variables in order, so we can chain them together in a single call:
```{r mutate2}
starwars %>% 
  select(name, birth_year) %>%
  mutate(dog_years = birth_year * 7, # separate with a comma
         comment = paste0(name, " is ", dog_years, " in dog years."))
```

---

# 4) dplyr::mutate

Boolean, logical, and conditional operators all work well with `mutate`:
```{r mutate3, eval = FALSE}
starwars %>% 
  select(name, height) %>%
  filter(name %in% c("Luke Skywalker", "Anakin Skywalker")) %>% 
  mutate(tall1 = height > 180) %>%
  mutate(tall2 = ifelse(height > 180, "Tall", "Short")) # same effect, but can choose labels
```

How many rows do you think this will return? How many columns?

--

```{r mutate3b, echo = FALSE}
starwars %>% 
  select(name, height) %>%
  filter(name %in% c("Luke Skywalker", "Anakin Skywalker")) %>% 
  mutate(tall1 = height > 180) %>%
  mutate(tall2 = ifelse(height > 180, "Tall", "Short")) # same effect, but can choose labels
```

---
name: summarize

# 5) dplyr::summarize

Often we want to get summary statistics or *collapse* our data

`summarize` provides an easy way to do this

--

**Example from Lab 2:** "What are the mininum, maximum, and average prices of the diamonds?"
```{r summ0}
diamonds %>% 
  summarize(min = min(price),      # calculate the min price
            max = max(price),      # calculate the max price
            average = mean(price)) # calculate the mean price
```

---

# 5) dplyr::summarize

Including "na.rm = TRUE" keeps NAs from propagating to the end result:

.pull-left[
```{r summ2l}
# Probably not what we want
starwars %>% 
  summarize(mh = mean(height))
```
]

.pull-right[
```{r summ2r}
# Much better
starwars %>% 
  summarize(mh = mean(height, na.rm = TRUE))
```
]

--

Is this a feature or a bug?

--

It depends on the context!

---

# Bonus: dplyr::group_by

`summarize` is particularly useful in combination with `group_by`:
```{r summ1}
starwars %>% 
  group_by(species, gender) %>% # for each species-gender combo
  summarize(mean_height = mean(height, na.rm = TRUE)) # calculate the mean height
```

---

# Bonus: dplyr::ungroup

```{r echo=FALSE, out.width='65%'}
knitr::include_graphics("img/03/group_by_ungroup.png")
```

Groups are persistent, `ungroup` removes them

---
class: inverse, center, middle
name: goodies

# Other dplyr goodies for your reference

---

# Other dplyr goodies: across

```{r echo=FALSE, out.width='70%'}
knitr::include_graphics("img/03/dplyr_across.png")
```

---

# Other dplyr goodies: across

Combining `mutate` with `across` allows you to work on a subset of variables:

```{r, mutate4}
starwars %>% 
  select(name:eye_color) %>% 
  mutate(across(where(is.character), toupper)) %>% # capitalize all character variables #<< 
  head(5)
```

---

# Other dplyr goodies: across

We can also use `across` within `summarize`:

```{r, summ4}
starwars %>% 
  group_by(species) %>% 
  summarize(across(where(is.numeric), mean, na.rm=T)) %>% # take the mean of all numeric variables #<< 
  head(5)
```
---

# Other dplyr goodies: count

`count` to get the number of observations:
.pull-left[
```{r}
starwars %>% 
  count(species)
```
]

.pull-right[
```{r}
starwars %>% 
  group_by(species) %>% summarize(num = n())
```
]

---

# Other dplyr goodies: distinct

`distinct` to isolate unique observations:
```{r}
starwars %>% distinct(species)
```



---

# Other dplyr goodies: window functions

[Window functions](https://cran.r-project.org/web/packages/dplyr/vignettes/window-functions.html) make it easy to get leads and lags, percentiles, cumulative sums, etc.
- See `vignette("window-functions")`

--

<br>

The final set of dplyr "goodies" worth mentioning are the family of join operations, but we'll come back to those later


